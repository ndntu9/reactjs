# Cập nhật trạng thái có tính chất không đồng bộ

Khi có 1 state thay đổi, React sẽ

1. Đánh dấu component đó "cần render lại"
2. Chờ cho đến khi tất cả event xử lý xong (ví dụ click, input, v.v.)
3. Sau đó mới gộp (batch) các thay đổi lại
4. Render lại 1 lần duy nhất

Ví dụ, có 2 state thay đổi là date và counter, nhưng React sẽ gộp 2 thay đổi đó vào và chỉ render lại 1 lần

```js
import React, { useState } from "react";

function App() {
    const [date, setDate] = useState(new Date());
    const [counter, setCounter] = useState(0);

    console.log("rendered");

    function handleButtonClick() {
        setDate(new Date());
        setCounter(counter + 1);
    }

    return <button onClick={handleButtonClick}>Click me</button>;
}
```

# Cập nhật trạng thái bằng hàm

Xem xét component sau

```js
import { useState } from "react";

function App() {
    const [counter, setCounter] = useState(0);

    function handleButtonClick() {
        setCounter(counter + 1);
        setCounter(counter + 1);
    }

    return <button onClick={handleButtonClick}>Click me {counter}</button>;
}
```

Khi gọi 2 lần `setCounter`, `counter` vẫn chưa được thay đổi do React chưa render lại, nên dù gọi 2 lần `setCounter` nhưng `counter` chỉ tăng lên 1

Để giải quyết vấn đề trên, React cung cấp khái niệm cập nhật trạng thái bằng hàm (functional state updates)

```js
import { useState } from "react";

function App() {
    const [counter, setCounter] = useState(0);

    function handleButtonClick() {
        setCounter((prevCounter) => prevCounter + 1);
        setCounter((prevCounter) => prevCounter + 1);
    }

    return <button onClick={handleButtonClick}>Click me {counter}</button>;
}
```

React sẽ lấy giá trị counter hiện tại, tạo ra 1 bản sao và gán bản sao đó cho prevCounter, khi này việc component có được render lại để thay đổi hay không không ảnh hưởng tới biến counter bên ngoài

Biến counter copy sẽ được cộng 2 lần, sau đó gán lại cho biến counter gốc
