# Giới thiệu về React.StrictMode

> React cung cấp component StrictMode giúp tìm ra một số lỗi không mong muốn khi React đang chạy ở môi trường dev

```js
import React from "react";
import { createRoot } from "react-dom/client";

function App() {}

const root = document.querySelector("#root");

createRoot(root).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>
);
```

# useEffect hook

> useEffect hook dùng để chạy code khi component được render lại hoặc khi dữ liệu bị thay đổi

Ví dụ

1. Gọi API
2. Ghi log
3. Cập nhật document.title
4. Đăng ký / gỡ sự kiện
5. Set timer, animation...
6. Đồng bộ state vào localStorage

# Tiêu đề trang

Trong React có thể thay đổi tiêu đề trang bằng cách sau

```js
document.title = "React Tutorial App";
```

Giả sử có 1 component và cần đồng bộ title với state counter, cần thực hiện như sau:

```js
import { useState, useEffect } from "react";

function Counter() {
    const [counter, setCounter] = useState(0);

    useEffect(() => {
        document.title = `Counter is ${counter}`;
    });

    function handleButtonClick() {
        setCounter((prevCounter) => prevCounter + 1);
    }

    return <button onClick={handleButtonClick}>Click me {counter}</button>;
}
```

> useEffect nhận đối số đầu tiên là 1 hàm, hàm này sẽ chạy mỗi khi dữ liệu thay đổi hoặc component được render lại

# Hiệu ứng yêu cầu dọn dẹp

1 số phương thức trong Javascript yêu cầu dọn dẹp, ví dụ sử dụng `setTimeout` trong `useEffect`

```js
import { useEffect } from "react";

function App() {
    useEffect(() => {
        setTimeout(() => {
            console.log("This will run in 1 second");
        }, 1_000);
    });

    return <h1>App</h1>;
}
```

Mỗi lần component được render lại, useEffect sẽ được chạy 1 lần, mỗi lần sẽ tạo ra 1 phạm vi hàm mới, mỗi phạm vi hàm lại chạy 1 lệnh setTimeout

Nếu không đóng lệnh setTimeout trong các hàm cũ trước khi chạy hàm mới, ứng dụng sẽ bị rò rỉ bộ nhớ (memory leak)

# Cách dọn dẹp hiệu ứng

useEffect sẽ return ra 1 function, function này sẽ được chạy trước khi chạy effect mới để clean đi các effect cũ

Ví dụ:

```js
import { useEffect, useState } from "react";

function App() {
    const [counter, setCounter] = useState(0);

    useEffect(() => {
        console.log("effect running");
        return () => {
            console.log("effect cleaning up");
        };
    });

    return (
        <>
            <h2>{counter}</h2>
            <button
                onClick={() => setCounter((prevCounter) => prevCounter + 1)}
            >
                Add
            </button>
        </>
    );
}
```

1. Trong lần đầu tiên component được render, `effect running` được in ra
2. Sau mỗi lần click vào button, counter thay đổi dẫn tới component bị render lại, `effect cleaning up` sẽ được in ra trước, sau đó `effect running` lại được in ra tiếp

# Dọn dẹp setTimeout

```js
import { useEffect } from "react";

function App() {
    useEffect(() => {
        setTimeout(() => {
            console.log("This will run in 1 second");
        }, 1_000);
    });

    return <h1>App</h1>;
}
```

JS cung cấp 1 hàm dùng để dọn dẹp setTimeout, đó là `clearTimeout(timerId)`

Ví dụ:

```js
const timerId = setTimeout(() => {
    console.log("this is supposed to run in 1 second");
}, 1_000);

clearTimeout(timerId);
```

Sử dụng clearTimeout trong useEffect

```js
import { useEffect } from "react";

function App() {
    useEffect(() => {
        const timerId = setTimeout(() => {
            console.log("This will run in 1 second");
        }, 1_000);

        return () => {
            clearTimeout(timerId);
        };
    });

    return <h1>App</h1>;
}
```

# Event listeners

Khi lắng nghe sự kiện trên 1 phần tử trong JSX, cần sử dụng onEvent, tuy nhiên để lắng nghe sự kiện trên đối tượng là window, cần phải lắng nghe và xóa bỏ sự kiện đã lắng nghe trong useEffect

Ví dụ

```js
import React, { useEffect } from "react";

function App() {
    function handleWindowScroll(event) {
        console.log("page scrolled");
    }

    useEffect(() => {
        window.addEventListener("scroll", handleWindowScroll, {
            passive: true
        });

        return () => {
            window.removeEventListener("scroll", handleWindowScroll, {
                passive: true
            });
        };
    });

    return (
        <>
            <h2>List of products</h2>
            <p>Lorem ipsum...</p>
        </>
    );
}
```
